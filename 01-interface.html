<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>interface</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="01-interface_files/libs/clipboard/clipboard.min.js"></script>
<script src="01-interface_files/libs/quarto-html/quarto.js"></script>
<script src="01-interface_files/libs/quarto-html/popper.min.js"></script>
<script src="01-interface_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="01-interface_files/libs/quarto-html/anchor.min.js"></script>
<link href="01-interface_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="01-interface_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="01-interface_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="01-interface_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="01-interface_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="interface" class="level1">
<h1>1. Interface</h1>
<p>The different steps of the creation/exploration/geovisualization of a flowmap are accessible through the interface of Arabesque.</p>
<blockquote class="blockquote">
<ol type="1">
<li>Importing flow dataset : at least one file for the links</li>
<li>Processing flow dataset (indicators calculation, …)</li>
<li>Geographical data computing : designing the map background (layers, …)</li>
<li>Cartographic symbolization : designing the flowmap signs (arrows, …)</li>
<li>Statistical data computing (filtering, …)</li>
<li>Export</li>
</ol>
</blockquote>
<section id="section" class="level3">
<h3 class="anchored" data-anchor-id="section"></h3>
</section>
<section id="general-structure" class="level2">
<h2 class="anchored" data-anchor-id="general-structure">1.1. General structure</h2>
<section id="section-1" class="level3">
<h3 class="anchored" data-anchor-id="section-1"></h3>
</section>
<section id="the-main-banner" class="level3">
<h3 class="anchored" data-anchor-id="the-main-banner">1.1.1. The main banner</h3>
<p><img src="images/main_banner.png" class="img-fluid"></p>
<p><img src="images/Buton_home.png" class="img-fluid"> Return to <a href="https://arabesque.univ-eiffel.fr/">the home page</a> to start a new view.</p>
<p><img src="images/main_doc.png" class="img-fluid"> Access to documentation</p>
<p><img src="images/main_about.png" class="img-fluid"> Access to credits</p>
<p><a href="https://www.univ-gustave-eiffel.fr/"><img src="images/main_univ-gustave-eiffel.PNG" class="img-fluid"></a> Access to documentationgo to the Gustave Eiffel University home page</p>
<p><a href="https://geoflowiz.hypotheses.org/accueil/le-projet-gflowiz"><img src="images/main_gflowiz_program.PNG" class="img-fluid"></a> go to the Geographic flow visualisation programme home page</p>
<p><a href="https://github.com/gflowiz"><img src="images/main_github-gflowiz.png" class="img-fluid"></a> go go to the home page of the <a href="https://github.com/gflowiz/arabesque-dev">github/com/glowiz</a></p>
</section>
<section id="the-three-panels" class="level3">
<h3 class="anchored" data-anchor-id="the-three-panels">1.1.2. The three panels</h3>
<p>Arabesque’ interface is composed of three panels.</p>
<ul>
<li>The <strong>central panel</strong> is for displaying the map - centered in France here.</li>
</ul>
<p>The two side panels are for playing with information:</p>
<ul>
<li><p>The <strong>left panel</strong> is for dealing with geometries and geographical layers.</p></li>
<li><p>The <strong>right panel</strong> is for fitering the flow data set. Here, only the flows up to</p></li>
</ul>
<p><img src="images/panels_arabesque.png" class="img-fluid"></p>
</section>
</section>
<section id="the-central-panel" class="level2">
<h2 class="anchored" data-anchor-id="the-central-panel">1.1. The central panel</h2>
<p>The central part of Arabesque corresponds to the <strong>map view</strong>. It results from the choice of the layers to be displayed (from the left panel) and the filtering of the values of the links and nodes (from the right panel).</p>
<p>This central panel also presents different buttons allowing the implementation of primary actions.</p>
<section id="primary-actions-with-butons" class="level3">
<h3 class="anchored" data-anchor-id="primary-actions-with-butons">1.1.1. Primary actions with butons</h3>
<p>The white page of Arabesque is decorated with blue action buttons.</p>
<p><img src="images/central_panel_clear.png" class="img-fluid"> <strong>Details of the different buttons</strong></p>
<p><img src="images/Buton_in_out.png" class="img-fluid"> Successively zoom in/out - the same way as with the mouse wheel.</p>
<p><img src="images/Buton_sauv.png" class="img-fluid"> Save the project in .ZIP for later use.</p>
<p><img src="images/Buton_export.png" class="img-fluid"> Export the map in .PDF vector format including legends in the bottom of the page.</p>
<p><img src="images/Buton_leg.png" class="img-fluid"> Show/hide the legend.</p>
</section>
<section id="primary-legend" class="level3">
<h3 class="anchored" data-anchor-id="primary-legend">1.1.2. Primary legend</h3>
<p>A legend is automatically generated for each map for nodes and links plot.</p>
<p><img src="images/center_legend.png" class="img-fluid"></p>
<p>The symbolization elements (size, color and opacity) of the nodes and links are included in the legend. Here (for a default map), it is the volume of flows and the degree of places that are represented.</p>
</section>
</section>
<section id="the-geographic-panel" class="level2">
<h2 class="anchored" data-anchor-id="the-geographic-panel">1.2. The geographic panel</h2>
<p>The left panel is to <strong>design the map</strong>:</p>
<ul>
<li><p>dealing with the map background as the geographical/geometrical layers: Arabesque reference layer, Tile Layer or your own geojson layers</p></li>
<li><p>customize the <em>design</em>/style of the nodes and links features map.</p></li>
</ul>
<p>The management of geographic information is composed of three sub-sections:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/geom_panel.png" class="img-fluid figure-img"></p>
<figcaption>General geographic information management panel</figcaption>
</figure>
</div>
<p>Actions on the <strong>background of the map</strong> are for changing projections of the current map and/or to add other layers : remote or personal one.</p>
<p>See <a href="./Design-map-background.html">Design map background</a> section.</p>
<p>Actions on the design/style is to set the parameters for the geometry of the lines/arrows and their semiology</p>
<p>See <a href="./Design-flowmap-signs.html">Design flowmap signs</a> section.</p>
</section>
<section id="the-geographic-layer-manager" class="level2">
<h2 class="anchored" data-anchor-id="the-geographic-layer-manager">1.2.1. The geographic layer manager</h2>
<p>In practice, a map is composed by several layer such as the bounding boxes, the graticules, the countries of land. All can be loaded in the map design background section Layers.</p>
<p>They then appear in the layer manager sub-panel, one above the other as shown below.</p>
<p><img src="images/Types_layers.png" class="img-fluid"></p>
<p>The present layers are all available on the map - but not necessarily all of them are visible.</p>
<p>The layers on the view are positioned in an order that affects their visibility. The top layer will be visible in the foreground.</p>
<section id="layer-rearrangement" class="level3">
<h3 class="anchored" data-anchor-id="layer-rearrangement">1.2.1. Layer rearrangement</h3>
<p>The drawing of the different layers and their objects can be finely parameterized in <em>Arabesque</em>, in order to take into account the possible complexity of the information (density of the matrix) which requires a particular management of the superimpositions and the arrangements of the layers of links and nodes.</p>
<p>In the example below, the largest links are placed in the foregroundby default, while the largest circles are not. After their rearrangement, the largest links are background and their color intensity has been changed (See Chapter <a href="./Design-flowmap-signs.html">Designing flowmap signs</a>).</p>
<p><em>EXAMPLE:</em> rearrangement of nodes and links.</p>
<p><img src="images/Dispositions.png" class="img-fluid"></p>
<p>The position of the layers above and below (foreground/lowerground) can be modified by a simple drag and drop.</p>
<p><img src="images/Layout_dragdrop.png" class="img-fluid"></p>
<blockquote class="blockquote">
<p><strong><em>Do it yourself !</em></strong>:</p>
</blockquote>
<p>– Click on the link layer and hold it down;</p>
<p>– Drag/drop the link layer and place it in the foreground;</p>
<p>– Release the layer;</p>
<p>– Repeat the same operation with the node layer if necessary._</p>
<p>After that, it can be seen that the layer of links has just been brought to the forefront.</p>
</section>
</section>
<section id="the-statistical-panel" class="level2">
<h2 class="anchored" data-anchor-id="the-statistical-panel">1.3. The statistical panel</h2>
<p>The <strong>right panel</strong> is for playing with the flow data sets : the nodes and/or links in order to <strong>filter the map</strong> with the Add filter button.</p>
<p><img src="images/Add_filter.PNG" class="img-fluid"></p>
<p>The statistics panel describes also the share (as a percentage) of flow information that is represented in the central view, before/after the application of a filter.</p>
<p><img src="images/Filter_statistics.png" class="img-fluid"></p>
<blockquote class="blockquote">
<p>Interpretation:</p>
<p>– for links: 1,3973 links are represented on the map, i.e.&nbsp;53.01% of the total number of links, which corresponds to a density (or matrix fill rate) of 53.01%. These links represent 49.31% of the total interaction.</p>
<p>– for nodes: 100% of nodes are represented (N=100 nodes)</p>
</blockquote>
<p>The filters applied are displayed in the second part of the panel, , depending on the type of data (continuous, categorical, etc.). See</p>
<p><img src="images/icon_links_filtering.png" class="img-fluid"> Filter on a link attribute</p>
<p><img src="images/icon_nodes_filtering.png" class="img-fluid"> Filter on a node attribute</p>
<p>See filtering flow data section.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>